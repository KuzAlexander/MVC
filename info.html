<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2>Схема работы MVC</h2>
    <p>
        1. Настройка Apache так чтобы все запросы шли на index.php<br>
        2. Подключаем к index.php<br>
            - Подключение init.php<br>
            - Подключение маршрутов routers.php<br>
            - объект App <br>
                Класс App <br>
                    - обьект Registry<br>
                    - обьект ErrorHandler <br>
                    - обьект Router<br>
                        Класс Router
                            - обьект $controller наследуется от AppController наследуется от Controller.<br>
                                $controller содержит:<br>
                                    - обьект класса Cache<br>
                                AppController содержит: <br>
                                    - обьект AppModel унаследован от Model<br>
                                        - Model создаст обьект Db<br>
                                            - Db содержит:<br>
                                                - подключит файл config_db.php<br>
                                                - подключится к базе данных R::setup()<br>
                                Controller содержит:<br>
                                    - метод getView()<br>
                                        - обьект View<br>
                                        - метод rendet() класса View<br>
    </p>
    <h2>Модель MVC</h2>
    <p>
        Структура приложения<br>
        app - папка которая содержит модели, контроллеры и виды нашего приложения<br>
        В папке app содержатся папки controllers, models, views и widgets<br>
        config - конфигурационные папки <br>
        public - находится публичная часть приложения (сюда будут переадресованы все запросы от пользователя)<br>
        tmp - хранятся временные файлы (логи ошибок, файлы кеша...)<br>
        Создаем файл composer.json<br>
        {<br>
            "autoload": {<br>
                "psr-4": {<br>
                    "ishop\\": "vendor/ishop/core",<br>
                    "app\\": "app"<br>
                }<br>
            },<br>
            "require": {}<br>
        }<br>
        В консоле переходим в нашу папку и набираем composer install<br>
        Далее в папке vendor создаем папку ishop - будет содержаться ядро (папка core)<br>
        В папке core будут папки base - базовые классы и libs - наши библиотеки<br>
    </p>
    <h2>Конфигурация приложения</h2>
    <p>
        В папке app есть папка controllers, где находятся контроллеры. Контроллеры будут подключаться в зависимости
        от того что ввел пользователь в адресной строке.<br>
        ishop2.loc/category - говорит нам что нужен контроллер категорий<br>
        ishop2.loc/product - говорит нам что нужен контроллер продуктов<br>
        Контроллер это класс. Если пользователь захочет удалить, изменить, добавить продукт, то он должен обратится
        к методу класса Контроллер (экшен - действие)<br>
        ishop2.loc/product/add - добавить продукт<br>
        ishop2.loc/product/view - посмотреть продукт<br>
        Если пользователь захочет обратиться к ishop2.loc/ - то нужно загрузить контроллер и экшен по умолчанию<br>
        В папке public размещаем файл index.php - это фронт-контроллер, точка входа<br>
        Чтобы был доступ к этому файлу нужно в корне проекта разместить файл .htaccess, где указать
        AddDefaultCharset utf-8 - кодировку по умолчанию<br>
        RewriteEngine On - включить перенаправление всех запросов<br>
        RewriteRule (.*) public/$1 - все запросы перенаправлять в папку public в переменную $1<br>
        Что бы все запросы которые попадают в папку public были отправлены на файл index.php, нужно
        в папке public создать файл .htaccess, где указать<br>
        RewriteCond %{REQUEST_FILENAME} !-f - если запрос не идет на конкретный файл<br>
        RewriteCond %{REQUEST_FILENAME} !-d - если запрос не идет на конкретную папку<br>
        RewriteRule (.*) index.php?$1 [L,QSA] - то отправить запрос $1 методом GET (дополнительные флаги
        [L,QSA] - L - последнее правило, QSA - если есть еще get параметры, то они не отбрасываются, а добавляются к $1)<br>
        В папке config создадим файл init.php и подключим его в файлу index.php<br>
        В файле init.php определим константы<br>
        - DEBUG - определяет режим разработки или продакшен (показывать или не показывать ошибки)<br>
        - путь к папкам<br>
        - подключаем автозагрузчик<br>
    </p>
    <h2>Класс Реестр</h2>
    <p>
        В папке ishop/core - создадим класс App (проверим автозагрузчик)<br>
        Укажим пространство имен namespaces ishop;<br>
        В классе App создадим конструктор и в переменную $query запишем что ищет пользователь<br>
        $query = trim($_SERVER['QUERY_STRING'], '/');<br>
        для свойства $app реализуем шаблон Реестр, создадим класс Registry в ishop/core<br>
        (self::$app = Registry::instance();)<br>
        Класс Registry должен реализоввывать паттерн синглтон (т.е. не создавать более чем одного обьекта данного класса)<br>
        Для этого созадим трейт Синглтон в ishop/core, и подключим его в класс Registry<br>
        В классе Registry будет свойство $properties, в которое складываем все свойства<br>
        И методы setProperty, getProperty<br>
        Создадим массив параметров params в папке config (будет возвращать массив настроек нашего приложения)<br>
        Создадим в классе App метод который будет возвращать все эти настройки getParams()<br>
        Создадим функцию debug(), в папке libs, которая будет доступна из любого места нашего приложения, (распечатка данных)<br>
    </p>
    <h2>Класс обработки ошибок</h2>
    <p>
        Создадим в ядре класс ErrorHandler, который будет обрабатывать исключения (найдена ли страница)<br>
        В конструкторе:<br>
        Проверяем константу DEBUG, в каком режиме мы находимся разработки или продакшен<br>
        Функция set_exception_handler() будет назначать функцию для отлова исключений<br>
        Создадим методы:<br>
        logErrors() - метод логирования ошибок<br>
            Функция error_log() будет иметь параметры:<br>
            1 - строка с датой, сообщением, файлом, линией. <br>
            2 - цифра 3 запись в файл<br>
            3 - путь к файлу <br>
        displayError() - метод для вывода ошибок<br>
            Отправляем заголовок с кодом http_response_code($responce)<br>
            Далее подключаем шаблон 404 ошибки по условию <br>
            Создадим в папке public папку errors с файлами 404.php для 404 ошибки, dev.php - для ошибок в режиме разработки,<br>
            prod.php - для ошибок в режиме продакшен<br>
            Далее в условии проверяем константу DEBUG, если значение 1, то будет подключена страница dev.php. Иначе prod.php.<br>
        exceptionHandler($e) - метод отлова ошибок<br>
            Подключим метод logErrors(), где в $e будет содержаться обьект выбрашенный функцией set_exception_handler() с методами<br>
            getMessage, getFile, getLine - сообщение, файл, строка<br>
            Подключим метод displayError(), где будет содержаться номер исключения "Исключение" и объект $e с методами <br>
            getMessage(), getFile(), getLine(), getCode())<br>
        <br>
        Для проверки работы класса обработки ошибок:<br>
        - создадим обьект класса ErrorHandler в классе App, new ErrorHandler();<br>
        - в index.php выбросим исключение throw new Exception('Страница не найдена', 404);<br>
        <br>
        Скачаем с сайта страницу с 404 ошибкой, и код положим в 404.php<br>
    </p>
    <h2>Класс маршрутизатор</h2>
    <p>
        Ключевой класс. Сравнивает поступающий запрос, с имеющими в нем маршрутами.<br>
        И определяет есть ли такая страница в нашем сайте или нет. <br>
        Домен/контроллер/экшен/страница - страница которую хотим посмотреть<br>
        Также есть возможность у пользователя указывать красивые имена Домен/контроллер/страница<br>
        Создадим:<br>
        config/routers - файл с правилами маршрутизации<br>
            Создадим админские и пользовательские правила, используются регулярные выражения. Более конкретные правила должны <br>
            находится выше чем общие. <br>
        core/Router - класс маршрутизатор<br>
            Свойства:<br>
                $routers = [] - хранится таблица маршрутов<br>
                $route = [] - запишем маршрут если он найден в $routes<br>
            Методы: <br>
            add() - записывает правила в таблицу маршрутов<br>
            getRouters() - для тестирования, возвращает массив маршрутов<br>
            getRoute() - для тестирования, возвращает текущий маршрут<br>
            dispatch($url) - принимает URL и если matchRoute() вернут true, то выводит страницу. <br>
                Все контроллеры у нас будет лежать в app/controllers. В переменную $controller сохраним строку <br>
                с найденными значениями и домавим постфикс Controller (для вызова тек классов, которые можно вызывать)<br>
                Проверим есть ли у нас класс с именем $controller<br>
                    Если класса нет, то выбросим исключение контроллер не найден<br>
                    Если класс есть, то сформируем объект контроллера и передадим туда маршрут<br>
                    $controllerObject = new $controller(self::$route);<br>
                    Теперь нужно вызвать метод контроллера - экшен. Т.к. в контроллере могут быть методы, которые мы не можем
                    вызывать, то добавим префикс 'Action'<br>
                    $action = self::$route['action'] . 'Action';<br>
                    Т.к. по PSR экшены должны быть вида viewAction, то нужно привести их к такому виду. Используем метод 
                    lowerCamelCase(). <br>
                    $action = self::lowerCamelCase(self::$route['action']) . 'Action';<br>
                    Теперь проверяем есть ли такой метод в данном объекте method_exist()<br>
                        Если метода нет, то выбросим исключение метод не найден<br>
                        Если метод есть, то вызовем данный метод<br>
                Если matchRoute() вернул false, то выбросим исключение throw new \Exception('Страница не найдена', 404);<br>
            <br>
            matchRoute($url) - принимает URL и ищет соответсвие в таблице маршрутов<br>
                Пробегаем в цикле по массиву $routes. С помощью функции preg_match ищем соответствие<br>
                регулярного выражения и переданного $url. Если есть соответствие, то занесем его в $matches.<br>
                (Более конкретные ругулярные выражения идут первыми и return true не дает циклу выполнятся далее)<br>
                Массив $matches будет содержать элементы с цифровыми и строковыми ключами, нам нужны строковые,<br>
                отсортируем.<br>
                Если пользовател ввел только контроллер, а экшет нет, то экшет сделаем равным index $route['action'] = 'index'.<br>
                Также понадобится в массиве $route, префикс. Для админки он есть, добавим ему слеш, а для пользовательской<br>
                части префикс сделаем равным пустой строке.<br>
                Массив $route сохраним в свойство $route. self::$route = $route;<br>
            <br>
            Т.к. регулярное выражение допускает имена page-new, а по PSR такое не допустимо, то нужно переделать в PageNew.<br>
            Создадим служебные методы:<br>
            upperCamelCase() - приводит контроллер к виду CamelCase<br>
                Приведем строку page-name к виду PageName <br>
                Добавим в метод matchRoute() обработку строки $route['controller'] = self::upperCamelCase($route['controller']);<br>
            <br>
            lowerCamelCase() - приводит экшeн к виду camelCase<br>
                Приведем строку page-name к виду pageName<br>
        <br>
        В базовом классе Add передаем маршрутизатору запрошенный адрес, Router::dispatch($query)<br>
        <br>
        Для проверки работы маршрутизатора создадим в папке app/controllers класс MainController и его метод indexAction<br>
    </p>
    <h2>Базовый контроллер</h2>
    <p>
        Чтобы узнать какой контроллер сейчас отрабатывает<br>
        Сделаем в классе MainController контструктор. (Т.к. мы передаем в класс контроллер маршрут)<br>
        Данный прием не практичен т.к. в каждом контроллере нужно создать такой же конструктор.<br>
        Для этого создадим базовый контроллер, который будет содержать общий код для всех контроллеров<br>
        В папке base создадим базовый контроллер (также будут садержатся базовые классы модель и вид)<br>
        abstract class Controller в нем создадим:
            - свойства $route, $controller, $model, $view, $prefix, <br>
            $data, $meta['title' => '', 'desc' => '', 'keywords' => ''], $layout.<br>
            (В папке views будут лежать папки видов контроллеров. Для контроллера MainController - Main, <br>
            в папке Main будет лежать экшен index (для метода indexAction()))<br>
            - конструктор и заполним все свойства<br>
        Базовый контроллер содержит код для всего фреймворка, но фреймворк может быть использован для различных<br>
        приложений (интернет магазин, блок...). Что бы не переписывать каждый раз базовый контрллер ядра для различных <br>
        приложений, создадим базовый контроллер нашего приложения.<br>
        В папке controllers создадим базовый контроллер нашего приложения AppController<br>
        Унаследуем базовый контроллер приложения от базового контроллера ядра<br>
        class AppController extends Controller<br>
        Подключим базовый контроллер ядра use ishop\base\Controller;<br>
        Унаследуем все контроллеры от базового контроллера приложения class MainController extends AppController<br>
        И подключим класс use ishop\base\AppController;<br>
        В базовом контроллере ядра напишим методы для работы с свойствами $data и $meta<br>
        set() - для заполнения $date, setMeta() - для заполнения $meta<br>
        Теперь создадим базовый класс вида View в папке base. Он будет содержать теже свойства, что и Controller<br>
        Конструктор будет принимать $route - маршрут, $layout - шаблон, $view - вид, $meta - мета данные<br>
        $layout - шаблон (не изменная часть страницы. Хедер, сайдбар, футер...)<br>
        $view - вид (динамическая часть страницы.)<br>
        Все шаблоны будут хранится в папке views/layouts/<br>
        Создадим шаблон по умолчанию default.php (Могут возникнуть случаи когда нужно применить шаблон по умолчанию,<br>
        другой какой-то шаблон или не применять шаблон вообще)<br>
        Выполним проверку $layout<br>
        Если выключен шаблон $layout === false, то $this->layout = false;<br>
        Иначе если передан шаблон, то возьмем его. Если шаблон не передан возьмем значение константы LAYOUT<br>
    </p>
    <h2>Класс View</h2>
    <p>
        Напишем метод рендер в базовом классе View, он будет формировать страничку для пользователя<br>
        render($data)<br>
        Данный метод необходимо вызывать в базовом контроллере ядра. Для этого в классе Controller создадим метод<br>
        getView(), который будет создавать объект вида и вызывать метод рендер.<br>
        Сам метод getView() будем вызывать в классе Router. После того как вызвали метод action() вызовем метод<br>
        $controllerObject->getView();<br>
        Далее в методе render() класса View, нужно сформировать путь к layout и путь к виду.<br>
        Путь к виду $viewFile = APP . "/views/{$this->prefix}{$this->controller}/{$this->view}.php";<br>
        В папке вида контроллера Main создадим файл index.php<br>
        Теперь нужно проверить существует ли файл is_file($viewFile), <br>
            - если файл существует нужно подключить его - require_once $viewFile; <br>
            файл будет без обертки - шаблона. Поэтому выводить его сразу не нужно. Положим его в буфер<br>
            ob_start();<br>
            require_once $viewFile; <br>
            $content = ob_get_clean();<br>
            - если не существует выбросить исключение - throw new \Exception("Не найден вид {$viewFile}", 500);<br>
        <br>
        Путь к шаблону, будем формировать если он не равен false. Проверим это в условии false !== $this->layout.<br>
        Путь к шаблону $layoutFile = APP . "/views/loayouts/{$this->layout}.php";<br>
        (Можем гибко менять шаблоны из файла init.php, из MainController, из indexAction())<br>
        Далее проверим существует ли файл is_file($layoutFile)<br>
            - если файл существует нужно подключит его - require_once $layoutFile;<br>
            (По умолчанию будет подключен ранне созданный в папке layouts шаблон default.php)<br>
            - если не существует выбросить исключение - throw new \Exception("Не найден шаблон {$this->layout}", 500);<br>
        <br>
        Чтобы в шаблон подключить вид (вид теперь содержится в переменной $content). Нужно в шаблоне default.php <br>
        указать переменную &lt;?=$content?><br>
        Создадим метод setMeta(), который будет выводить готовые мета теги в шаблон.<br>
        Создадим переменную $output в которую будем писать мета теги. Далее вернем переменую $output из метода.<br>
        В шаблоне default.php вызовем метод getMeta().<br>
        Чтобы параметры были не пусты в MainController укажем $this->setMeta('Главная страница', 'Описание', 'Ключевики');<br>
        Чтобы вывести данные $data, мы их передаем в метод $render() из контроллера MainController<br>
        Укажем в MainController - $this->set(compact('name', 'age'));<br>
        Данные в классе View извлекаются в переменные extract($data). <br>
        И теперь доступны в любом из наших видов Main/index.php. Т.е. данные передаются из контроллера в вид.<br>
    </p>   
    <h2>Класс модели</h2>       
    <p>
        Если в url указать get параметры, то будет ошибка т.к. не найдена страница.<br>
        Данная ошибка связана с тем, что в маршрутах у нас указано "^$".<br>
        Для избежания данной ошибки вырежим гет параметры из строки в классе Router.<br>
        Создадим метд removeQueryString() и вызовем его в методе dispatch()<br>
        Если распечатать $url = http://ishop2.loc/page/view/?id=1 то получим page/view/&id=1.<br>
        Все это есть гет параметры. Из-за того что в файле .htaccess указали RewriteRule (.*) index.php?$1 [L,QSA]<br>
        стоит флаг QSA, который говорит дописать гет параметры (будут дописаны гет параметры через &)<br>
        В методе removeQueryString(), проверим не пуст ли $url, и елси он не пуст, то запишем гет параметры<br>
        в массив состоящий не более чем из 2 элементов <br>
        Проверим есть ли в 0 элементе массива знак =<br>
            - если знака нет, то обрежем / и вернем $params[0]<br>
            - если есть, то вернем пустую строку<br>
        <br>
        В папке base создадим абстрактный класс Model, который будет отвечать за работу с данными <br>
        Данные могут быть база данных, а могут быть волидация данных, функции закгрузки данных <br>
        Поля:<br>
        public $attributes - массив свойств модели, который будет идентичев полям в базе данных.<br>
        Нужны для автоматической загрузки данных из форм в модель, и загрузки их в базу данных.<br>
        $errors - будем складывать ошибки<br>
        $rules - для правил валидации данных<br>
        Создадим конструктор, в котором организуем подключение к базе данных<br>
        Нам потребуется база данных и настройка соединений с базой данных<br>
        Настройка соединений с базой данных будет находится в папке config. Файл config_db. <br>
        Нужно создать базу данных OSPanel - флажок - дополнительно - phpMyAdmin - база данных<br>
        Имя базы данных ishop2, рядом выбираем сравнение, нажимаем создать.<br>
        В базе данных ishop2 создаем таблицу с именем test и 2 столбцами, нажимаем вперед.<br>
        Задаем <br>
            имя поля id, атрибут unsigned (беззнака), индекс primary (первичный ключ) нажать вперед, A_I ставим галочку<br>
            имя поля title, тип varchar, длинна значение 255 (символов), null - ставим галочку (null по умолчанию)<br>
        Нажимаем Сохранить<br>
        Т.о. у нас получилась база данных ishop и таблица test<br>
        Для работы с базой данных будем использовать ORM RedBeanPHP (документация на сайте redbeanphp.com)<br>
        <br>
        Наш файл config_db будет возвращать массив настроек соединений с базой данных. Три элемента<br>
        'dsn', 'user', 'pass'<br>
        Также потребутеся специальный класс Db в папке core. В данном классе будет устанавливаться подключение к серверу<br>
        базы данных.<br>
        Класс Db должен реализоввывать паттерн Синглтон, нужно подключить трейт TSingletone.php<br>
        Создадим защищенный конструктор<br>
        Переменная $db будет содержать массив из файла config_db<br>
        Нужно подключится к серверу базы данных используя RedBeanPHP<br>
    </p>  
    <h2>ORM RedBeanPHP</h2>
    <p>
        Установка библиотеки ORM RedBeanPHP<br>
        Перейдем на сайте packagist.org, найдем ORM RedBeanPHP - gabordemooij/redbean<br>
        Скопируем зависимость "gabordemooij/redbean": "dev-master"<br>
        В файле composer.json вставим в require зависимость<br>
        Заходим в консоль - cd domains/ishop2.loc - composer install (появится папка gabordemooij)<br>
        Переходим в класс Db подключаем use \RedBeanPHP\R;<br>
        в конструкторе пишем <br>
        R::setup($db['dsn'], $db['user'], $db['pass']); - подключение к базе данных<br>
        Проверим установленно ли соединение if (!R::testConnection())<br>
            - если не установленно выбросим исключение<br>
        Что бы проверить соединение, создадим в конструкторе класса Model объект Db::instance();<br>
        Далее создадим базовую модель класс models/AppModel.php унаследуем от базовой модели фреймворка Model<br>
        Т.к соединение с базой данных потребуется на любой странице, то в AppController создадим объект AppModel<br>
        в конструкторе запишем:<br>
            parent::__construct($route);<br>
            new AppModel;<br>
        Т.е. объект AppModel вызовет конструктор класса Model, тот создаст объект Db, а тот вызовет подключение к БД<br>
        Сделаем запрос из нашей таблице базы данных. Создадим в этой таблице что-нибудт<br>
        нажимаем на нашу таблицу test - Вставить - Статья 1 / Статья 2 (значение в столбце title) - Вперед<br>
        Если нажать на Обзор, то будет видны два заголовка<br>
        В MainController получим статьи из БД (use \RedBeanPHP\R;) $posts = R::findAll('test') - массив<br>
        Передадим этот массив в метод $this->set(compact('name', 'age', 'names', 'posts'));<br>
        теперь данные доступны в Main/index.php выведим их <br>
        foreach ($posts as $post) {<br>
            echo "&lt;h3&gt;$post->title&lt;/h3&gt;";<br>
        }<br>
        RedBeanPHP может добавлять, удалять строчки из таблицы на лету. Это может понадобится в разработке. Что бы запретить <br>
        это в продакшен нужно вызвать метод R::freeze(true) (документация)<br>
        Если режим отладки, то еще включим отладку RedBeanPHP - R::debug(true, 1)<br>
        Что бы получить все запросы которые мы выполняем запишем в шаблоне (layout/default.php) код <br>
        (use \RedBeanPHP\R;) - подключим класс R<br>
        $logs = R::getDatabaseAdapter()<br>
            ->getDatabase()<br>
            ->getLogger();<br>
            debug( $logs->grep( 'SELECT' ) );<br>
    </p>
    <h2>Класс для кеширования</h2>
    <p>
        Кеш необходим для того чтобы снизить нагрузку на сервер базы данных. Пример если есть меню, то брать его из кеша, если<br>
        меню нет, то формировать его и класть в кеш.<br>
        Создаем новый класс core/Cache<br>
        Будет реализовывать паттерн Синглтон подключим use TSingletone<br>
        Создадим методы:<br>
            - set($key, $data, $seconds = 3600) - положим данные в кеш<br>
                $key - задает уникальное имя файла <br>
                $data - данные <br>
                $seconds - время сохранения кеша в секундах<br>
                Проверим если $seconds = 0, не хотим кешировать <br>
                Создадим массив $content и положим туда данные и конечное время кеширования<br>
                Далее пытаемся положить данные в кеш функция file_put_contents(путь к файлу, контент который кладем)<br>
                название файла будем брать из шифрования md5($key) (что бы пользователь не положил в $key не допустипое <br>
                значение для файловой системы)<br>
                второй параметр контент - положим весь массив $content<br>
                Если удалось положить в кеш, то вернем true<br>
            - get($key) - получим данные из кеша<br>
                Получать будем по ключу. Укажим путь к файлу $file = CACHE . '/' . md5($key) . '.txt';<br>
                Проверим, <br>
                    если файл существует, то в переменную $content положим то, что лежит в файле<br>
                    $content = unserialize(file_get_contents($file));<br>
                        Проверяем не устарели ли кешированные данные <br>
                            если не устарели, то вернем данные $content<br>
                        если данные устарели удалим файл unlink($file)<br>
                    если файла не существует вернем false<br>
            - delete() - удалить данные из кеша<br>
                Проверим, если файл существует, то удалим его<br>
        <br>
        Для проверки работоспособности класса Cache, в MainController создадим объект класса Cache<br>
        $cache = Cache::instance();<br>
        // $cache->delete('test'); - удаление файла из кеша<br>
        $data = $cache->get('test'); - получаем данные из кеша<br>
        if (!$data) { если получили false<br>
            $cache->set('test', $names); заносим в кеш данные<br>
        }<br>
        debug($data); <br>
    </p>
    <h2>Схема работы MVC</h2>
    <p>
        1. Настройка Apache так чтобы все запросы шли на index.php<br>
        2. Подключаем к index.php файл init.php<br>
            - Пути к файлам<br>
            - Подключение автозагрузчика<br>
            - Подключение маршрутов routers.php<br>
                - заполняет таблицу маршрутов $routes (класс Router)<br>
            - Создаем объект класса App <br>
                Класс App <br>
                    - query - определяет что ищет пользователь<br>
                    - в свойство app записываем обьект класса Registry<br>
                        - можем получить данные из файла params.php<br>
                    - Создадим обьект класса обработки исключений ErrorHandler <br>
                        - класс ErrorHandler<br>
                            - Проверяет какой режим включен<br>
                            - Записывает исключение в файл <br>
                            - Выводит исключение на экран<br>
                    - Создадим обьект класса маршрутизатора и передадим запрос пользователя в метод класса Router<br>
                        - Ищем соответствие между запросом и таблицей маршрутов<br>
                            - Если соответсвие есть, то формируем строку $controller из запроса<br>
                                - Проверяем есть ли у нас класс с именем $controller<br>
                                    - если есть, то создадим объект этого класса и передадим туда маршрут<br>
                                        - обьект будет наследоваться от класса AppController, который будет наследоваться<br>
                                        от класса Controller.<br>
                                        Обьект будет содержать:<br>
                                            - $data из базы данных <br>
                                            - обьект класса Cache<br>
                                            - $meta теги мета<br>
                                        AppController будет содержать: <br>
                                            - создание обьекта AppModel, который унаследован от Model<br>
                                                - Model создаст обьект Db<br>
                                                    - Db сделает:<br>
                                                        - подключит файл config_db.php<br>
                                                        - подключится к базе данных R::setup()<br>
                                        Controller будет содержать:<br>
                                            - свойства $route, $controller, $model, $view, $prefix, <br>
                                                $data, $meta['title' => '', 'desc' => '', 'keywords' => ''], $layout.<br>
                                            - конструктор для заполнения свойств<br>
                                            - методы set() - для заполнения $date, setMeta() - для заполнения $meta<br>
                                    - сформируем строку $action<br>
                                    - Проверим, есть ли в классе $controller метод $action<br>
                                        - если есть, то вызовем этот метод<br>
                                            в методе доступны свойства класса Controller - set(), setMeta()<br>
                                        - вызовем метод getView()<br>
                                            - Создаст обьект класса View и передаст туда $route, $layout, $view, $meta<br>
                                                - заполнит все поля класса View<br>
                                            - Вызовет метод rendet() класса View и передаст туда $data<br>
                                                - если файл существует подключем его<br>
                                                - если нет, то выбросим исключение<br>
                                                - если шаблон существует подключем его<br>
                                                - если нет, то выбросим исключение<br>
                                                (т.о из MainController будут переданы $data, $meta, <br>
                                                а из Controller будет передано $route, $layout, $view)<br>
                                    - если нет, то выбросим исключение<br>
                                - если нет, то выбросим исключение <br>
                            - если нет, то выбросим исключение<br>
    </p>            
</body>
</html>